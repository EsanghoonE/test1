<!DOCTYPE html>

<html lang="ko">

  <head>

    <meta charset="UTF-8">

    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>ìë™ì°¨ ì‚°ì—… ì—­ì‚¬ í€´ì¦ˆ - AI ê¸°ë°˜ ìˆ˜ì—… ë„ìš°ë¯¸</title>

    <!-- Tailwind CSS CDN -->

    <script src="https://cdn.tailwindcss.com"></script>

    

    <!-- Game Boy ìŠ¤íƒ€ì¼ CSS -->

    <style>

        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        

        /* 1. Game Boy ë³¸ì²´ ë°°ê²½ ë° ì¼ë°˜ í…ìŠ¤íŠ¸ ìƒ‰ìƒ */

        body {

            font-family: 'Press Start 2P', monospace; /* ë ˆíŠ¸ë¡œ í”½ì…€ í°íŠ¸ (í´ë°±: monospace) */

            background-color: #D3D3D3; /* ë°ì€ íšŒìƒ‰ (ë³¸ì²´ í”Œë¼ìŠ¤í‹±) */

            color: #222222; /* ì§„í•œ íšŒìƒ‰ í…ìŠ¤íŠ¸ */

            transition: background-color 0.3s, color 0.3s;

        }

        /* 2. Game Boy í™”ë©´ ìƒ‰ìƒ (ë…¹ìƒ‰/ê²€ì€ìƒ‰ 4ë‹¨ê³„ í†¤ ì¤‘ 2ê°€ì§€ ì‚¬ìš©) */

        .gameboy-screen-bg {

            background-color: #9BBC0F; /* ë°ì€ ë…¹ìƒ‰/ë…¸ë€ìƒ‰ í™”ë©´ */

            color: #0F380F; /* ì§„í•œ ë…¹ìƒ‰ í”½ì…€ ìƒ‰ìƒ */

        }

        .gameboy-screen-border {

            border-color: #0F380F;

        }

        /* 3. ë²„íŠ¼ 3D ì„€ë„ìš°ë¥¼ Game Boy ëŠë‚Œì— ë§ê²Œ ì¡°ì • */

        .gameboy-button-shadow-red {

            box-shadow: 0 4px 0 0 #800000; /* ì–´ë‘ìš´ ë¹¨ê°„ìƒ‰ ê·¸ë¦¼ì */

        }

        .gameboy-button-shadow-gray {

            box-shadow: 0 4px 0 0 #333333; /* ì–´ë‘ìš´ íšŒìƒ‰ ê·¸ë¦¼ì */

        }

    </style>

  </head>

  <body>

<!-- ë©”ì¸ ì• í”Œë¦¬ì¼€ì´ì…˜ ì»¨í…Œì´ë„ˆ (ë ˆíŠ¸ë¡œ ì½˜ì†” ë³¸ì²´ í”„ë ˆì„) -->

<div id="app" class="min-h-screen flex items-center justify-center p-4">

    <div class="w-full max-w-lg bg-[#D3D3D3] rounded-xl p-8 md:p-12 

                border-8 border-[#333333] 

                shadow-2xl shadow-[#333333]/50"> <!-- ê¹Šì€ ê·¸ë¦¼ì -->

        <h1 class="text-xl md:text-2xl font-bold text-center text-[#222222] mb-4 tracking-tighter">

            ìë™ì°¨ ì‚°ì—… ì—­ì‚¬ í€´ì¦ˆ

        </h1>

        <p class="text-center text-xs mb-6 text-[#555555]">

            ì£¼ì œë¥¼ ì…ë ¥í•˜ê³  AIê°€ ìƒì„±í•œ í€´ì¦ˆë¡œ ì¬ë¯¸ìˆê²Œ ìˆ˜ì—…ì„ ì§„í–‰í•˜ì„¸ìš”!

        </p>

        <!-- í€´ì¦ˆ ìƒì„± ì˜ì—­ -->

        <div id="quiz-generation-area" class="space-y-4">

            <!-- ì…ë ¥ì°½ (Game Boy í™”ë©´ ìŠ¤íƒ€ì¼) -->

            <input type="text" id="topic-input" placeholder="ì˜ˆ: í¬ë“œ ëª¨ë¸ Tì˜ ì˜í–¥"

                   class="w-full p-3 rounded-sm gameboy-screen-bg text-[#0F380F] placeholder-[#0F380F]/70 

                          focus:outline-none focus:ring-0 border-2 gameboy-screen-border transition duration-150 text-sm">

            

            <!-- í€´ì¦ˆ ìƒì„± ë²„íŠ¼ (Game Boy A/B ë²„íŠ¼ ìŠ¤íƒ€ì¼) -->

            <button id="generate-button"

                    class="w-full py-3 px-6 bg-[#CC0000] hover:bg-[#A00000] text-white font-bold rounded-lg 

                           gameboy-button-shadow-red transition duration-100 transform 

                           active:translate-y-1 active:shadow-none text-sm"> 

                í€´ì¦ˆ ìƒì„± (START)

            </button>

            <div id="status-message" class="text-center text-xs h-5 text-red-600"></div>

        </div>

        <!-- í€´ì¦ˆ í”Œë ˆì´ ì˜ì—­ (ì´ˆê¸°ì—ëŠ” ìˆ¨ê¹€) -->

        <div id="quiz-game-area" class="hidden mt-8 space-y-6">

            <div class="flex justify-between items-center text-sm font-bold text-[#222222]">

                <span id="score-display">ì ìˆ˜: 0</span>

                <span id="question-count">ë¬¸ì œ: 0 / 0</span>

            </div>

            <!-- í˜„ì¬ ë¬¸ì œ ì¹´ë“œ (Game Boy í™”ë©´) -->

            <div id="question-card" class="gameboy-screen-bg p-4 rounded-sm shadow-inner border-2 gameboy-screen-border">

                <p id="current-question" class="text-sm font-semibold mb-2 text-[#0F380F] leading-relaxed">ë¬¸ì œ ì¤€ë¹„ ì¤‘...</p>

            </div>

            <!-- ë‹µë³€ ë²„íŠ¼ë“¤ (ë‹¤í¬ ê·¸ë ˆì´ ë²„íŠ¼ ìŠ¤íƒ€ì¼) -->

            <div id="options-container" class="space-y-3">

                <!-- ë‹µë³€ ë²„íŠ¼ì´ ì—¬ê¸°ì— ë™ì ìœ¼ë¡œ ì¶”ê°€ë©ë‹ˆë‹¤. -->

            </div>

            <!-- í”¼ë“œë°± ë©”ì‹œì§€ ë°•ìŠ¤ -->

            <div id="feedback-message" class="p-3 rounded-sm text-center text-xs font-bold transition duration-300 hidden text-white"></div>

        </div>

    </div>

</div>

<script type="module">

    // Firebase ê´€ë ¨ ì „ì—­ ë³€ìˆ˜ (Firestoreë¥¼ ì‚¬ìš©í•˜ì§€ ì•Šìœ¼ë¯€ë¡œ ì‚¬ìš©í•˜ì§€ ì•ŠìŒ)

    // const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

    // const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};

    // const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : '';

    

    // Gemini API ì„¤ì •

    const API_KEY = import.meta.env?.VITE_GEMINI_API_KEY ?? '';

    const API_MODEL = 'gemini-2.5-flash-preview-09-2025';

    const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/${API_MODEL}:generateContent?key=${API_KEY}`;

    // TTS API ì„¤ì •

    const TTS_MODEL = 'gemini-2.5-flash-preview-tts';

    const TTS_URL = `https://generativelanguage.googleapis.com/v1beta/models/${TTS_MODEL}:generateContent?key=${API_KEY}`;

    // DOM ìš”ì†Œ ìºì‹œ

    const topicInput = document.getElementById('topic-input');

    const generateButton = document.getElementById('generate-button');

    const statusMessage = document.getElementById('status-message');

    const quizGenerationArea = document.getElementById('quiz-generation-area');

    const quizGameArea = document.getElementById('quiz-game-area');

    const scoreDisplay = document.getElementById('score-display');

    const questionCountDisplay = document.getElementById('question-count');

    const currentQuestionEl = document.getElementById('current-question');

    const optionsContainer = document.getElementById('options-container');

    const feedbackMessage = document.getElementById('feedback-message');

    // ê²Œì„ ìƒíƒœ ë³€ìˆ˜

    let currentQuiz = [];

    let currentQuestionIndex = 0;

    let score = 0;

    let isProcessing = false;

    // TTS (Text-to-Speech) ê´€ë ¨ ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜

    // Signed 16-bit PCM ë°ì´í„°ë¥¼ WAV íŒŒì¼ í˜•ì‹ìœ¼ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.

    function pcmToWav(pcm16, sampleRate) {

        const numChannels = 1;

        const bitsPerSample = 16;

        const byteRate = sampleRate * numChannels * (bitsPerSample / 8);

        const blockAlign = numChannels * (bitsPerSample / 8);

        const dataLength = pcm16.byteLength;

        const totalLength = 44 + dataLength;

        const buffer = new ArrayBuffer(totalLength);

        const view = new DataView(buffer);

        let offset = 0;

        // RIFF chunk

        view.setUint32(offset, 0x52494646, false); offset += 4; // "RIFF"

        view.setUint32(offset, totalLength - 8, true); offset += 4; // ChunkSize

        view.setUint32(offset, 0x57415645, false); offset += 4; // "WAVE"

        // fmt chunk

        view.setUint32(offset, 0x666d7420, false); offset += 4; // "fmt "

        view.setUint32(offset, 16, true); offset += 4; // Subchunk1Size (16 for PCM)

        view.setUint16(offset, 1, true); offset += 2; // AudioFormat (1 for PCM)

        view.setUint16(offset, numChannels, true); offset += 2; // NumChannels

        view.setUint32(offset, sampleRate, true); offset += 4; // SampleRate

        view.setUint32(offset, byteRate, true); offset += 4; // ByteRate

        view.setUint16(offset, blockAlign, true); offset += 2; // BlockAlign

        view.setUint16(offset, bitsPerSample, true); offset += 2; // BitsPerSample

        // data chunk

        view.setUint32(offset, 0x64617461, false); offset += 4; // "data"

        view.setUint32(offset, dataLength, true); offset += 4; // Subchunk2Size

        // PCM data

        const dataArray = new Uint8Array(buffer, offset);

        dataArray.set(new Uint8Array(pcm16.buffer));

        return new Blob([buffer], { type: 'audio/wav' });

    }

    // Base64 ë¬¸ìì—´ì„ ArrayBufferë¡œ ë””ì½”ë”©

    function base64ToArrayBuffer(base64) {

        const binaryString = atob(base64);

        const len = binaryString.length;

        const bytes = new Uint8Array(len);

        for (let i = 0; i < len; i++) {

            bytes[i] = binaryString.charCodeAt(i);

        }

        return bytes.buffer;

    }

    

    // TTSë¥¼ ì‚¬ìš©í•˜ì—¬ í…ìŠ¤íŠ¸ë¥¼ ìŒì„±ìœ¼ë¡œ ì¬ìƒí•˜ëŠ” í•¨ìˆ˜ (Kore ëª©ì†Œë¦¬ ì‚¬ìš©)

    async function speak(text, voiceName = "Kore") {

        if (!text) return;

        const payload = {

            contents: [{ parts: [{ text: text }] }],

            generationConfig: {

                responseModalities: ["AUDIO"],

                speechConfig: {

                    voiceConfig: {

                        prebuiltVoiceConfig: { voiceName: voiceName }

                    }

                }

            },

        };

        const maxRetries = 3;

        for (let i = 0; i < maxRetries; i++) {

            try {

                const response = await fetch(TTS_URL, {

                    method: 'POST',

                    headers: { 'Content-Type': 'application/json' },

                    body: JSON.stringify(payload)

                });

                

                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);

                const result = await response.json();

                const part = result?.candidates?.[0]?.content?.parts?.[0];

                const audioData = part?.inlineData?.data;

                const mimeType = part?.inlineData?.mimeType;

                if (audioData && mimeType && mimeType.startsWith("audio/")) {

                    const sampleRateMatch = mimeType.match(/rate=(\d+)/);

                    if (!sampleRateMatch) throw new Error("Sample rate not found in mimeType.");

                    

                    const sampleRate = parseInt(sampleRateMatch[1], 10);

                    const pcmData = base64ToArrayBuffer(audioData);

                    const pcm16 = new Int16Array(pcmData);

                    

                    const wavBlob = pcmToWav(pcm16, sampleRate);

                    const audioUrl = URL.createObjectURL(wavBlob);

                    

                    const audio = new Audio(audioUrl);

                    audio.play();

                    return; // ì„±ê³µì ìœ¼ë¡œ ì¬ìƒí–ˆìœ¼ë¯€ë¡œ ë£¨í”„ ì¢…ë£Œ

                } else {

                    throw new Error("TTS ì‘ë‹µì—ì„œ ìœ íš¨í•œ ì˜¤ë””ì˜¤ ë°ì´í„°ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");

                }

            } catch (error) {

                console.error(`TTS API í˜¸ì¶œ ì‹¤íŒ¨ (ì‹œë„ ${i + 1}):`, error);

                if (i < maxRetries - 1) {

                    await new Promise(resolve => setTimeout(resolve, Math.pow(2, i) * 1000)); // Exponential backoff

                } else {

                    statusMessage.textContent = 'ìŒì„± ì¬ìƒì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. (ì½˜ì†” í™•ì¸)';

                }

            }

        }

    }

    /**

     * Gemini APIë¥¼ í˜¸ì¶œí•˜ì—¬ êµ¬ì¡°í™”ëœ í€´ì¦ˆ ì½˜í…ì¸ ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.

     */

    async function generateQuizContent(topic) {

        // ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸ë¥¼ ìë™ì°¨ ì‚°ì—… ì—­ì‚¬ ì „ë¬¸ê°€ë¡œ ë³€ê²½

        const systemPrompt = "ë‹¹ì‹ ì€ ìë™ì°¨ ì‚°ì—… ì—­ì‚¬ êµìœ¡ ì½˜í…ì¸ ë¥¼ ìƒì„±í•˜ëŠ” AI ì „ë¬¸ê°€ì…ë‹ˆë‹¤. ì‚¬ìš©ìê°€ ìš”ì²­í•œ ì£¼ì œì— ê¸°ë°˜í•˜ì—¬ 4ì§€ì„ ë‹¤í˜• ê°ê´€ì‹ í€´ì¦ˆë¥¼ ìƒì„±í•˜ì„¸ìš”. ë‹µë³€ì€ ë°˜ë“œì‹œ ì œê³µëœ JSON ìŠ¤í‚¤ë§ˆë¥¼ ë”°ë¼ì•¼ í•©ë‹ˆë‹¤.";

        // í€´ì¦ˆ ìš”ì²­ ë‚´ìš©ì— 'ìë™ì°¨ ì—­ì‚¬'ë¥¼ ì¶”ê°€í•˜ì—¬ ëª…í™•í•˜ê²Œ ì»¨í…ìŠ¤íŠ¸ë¥¼ ì§€ì •

        const userQuery = `${topic}ì— ëŒ€í•œ ìë™ì°¨ ì—­ì‚¬ ê°ê´€ì‹ í€´ì¦ˆ 5ê°œë¥¼ ìƒì„±í•´ ì£¼ì„¸ìš”. ê° í€´ì¦ˆëŠ” 4ê°œì˜ ì˜µì…˜ê³¼ ì •ë‹µ, ê·¸ë¦¬ê³  ê°„ê²°í•œ í•´ì„¤ì„ í¬í•¨í•´ì•¼ í•©ë‹ˆë‹¤.`;

        

        const responseSchema = {

            type: "ARRAY",

            items: {

                type: "OBJECT",

                properties: {

                    question: { "type": "STRING", description: "í€´ì¦ˆ ì§ˆë¬¸ì…ë‹ˆë‹¤." },

                    options: { "type": "ARRAY", items: { "type": "STRING" }, description: "4ê°œì˜ ë³´ê¸° í•­ëª©ì…ë‹ˆë‹¤." },

                    correctAnswer: { "type": "STRING", description: "ì •ë‹µ ë³´ê¸°ì˜ í…ìŠ¤íŠ¸ì…ë‹ˆë‹¤." },

                    explanation: { "type": "STRING", description: "ì •ë‹µì— ëŒ€í•œ ê°„ê²°í•œ í•´ì„¤ì…ë‹ˆë‹¤." }

                },

                required: ["question", "options", "correctAnswer", "explanation"]

            }

        };

        const payload = {

            contents: [{ parts: [{ text: userQuery }] }],

            systemInstruction: { parts: [{ text: systemPrompt }] },

            generationConfig: {

                responseMimeType: "application/json",

                responseSchema: responseSchema,

                // Google Search groundingì„ ì‚¬ìš©í•˜ì—¬ ìµœì‹  ì •ë³´ë¥¼ ë°”íƒ•ìœ¼ë¡œ í€´ì¦ˆë¥¼ ìƒì„±í•©ë‹ˆë‹¤.

                tools: [{ "google_search": {} }],

            },

        };

        const maxRetries = 3;

        for (let i = 0; i < maxRetries; i++) {

            try {

                const response = await fetch(API_URL, {

                    method: 'POST',

                    headers: { 'Content-Type': 'application/json' },

                    body: JSON.stringify(payload)

                });

                

                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);

                const result = await response.json();

                const jsonText = result.candidates?.[0]?.content?.parts?.[0]?.text;

                

                if (jsonText) {

                    // LLMì€ JSONì„ ë¬¸ìì—´ë¡œ ë°˜í™˜í•˜ë¯€ë¡œ íŒŒì‹±í•©ë‹ˆë‹¤.

                    const parsedData = JSON.parse(jsonText);

                    return parsedData;

                } else {

                    throw new Error("AIë¡œë¶€í„° ìœ íš¨í•œ í€´ì¦ˆ ë°ì´í„°ë¥¼ ë°›ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.");

                }

            } catch (error) {

                console.error(`API í˜¸ì¶œ ì‹¤íŒ¨ (ì‹œë„ ${i + 1}):`, error);

                if (i < maxRetries - 1) {

                    await new Promise(resolve => setTimeout(resolve, Math.pow(2, i) * 1000)); // Exponential backoff

                } else {

                    throw new Error("í€´ì¦ˆ ìƒì„± API í˜¸ì¶œ ì¤‘ ìµœì¢… ì˜¤ë¥˜ ë°œìƒ.");

                }

            }

        }

    }

    /**

     * UI ì—…ë°ì´íŠ¸ ë° ë‹¤ìŒ ë¬¸ì œë¡œ ë„˜ì–´ê°€ëŠ” í•¨ìˆ˜

     */

    function loadQuestion() {

        if (currentQuestionIndex >= currentQuiz.length) {

            // ëª¨ë“  í€´ì¦ˆ ì™„ë£Œ

            showEndGame();

            return;

        }

        const q = currentQuiz[currentQuestionIndex];

        currentQuestionEl.textContent = `${currentQuestionIndex + 1}. ${q.question}`;

        questionCountDisplay.textContent = `ë¬¸ì œ: ${currentQuestionIndex + 1} / ${currentQuiz.length}`;

        optionsContainer.innerHTML = ''; // ì˜µì…˜ ì´ˆê¸°í™”

        feedbackMessage.classList.add('hidden');

        feedbackMessage.textContent = '';

        

        // ì§ˆë¬¸ì„ ìŒì„±ìœ¼ë¡œ ì½ì–´ì¤ë‹ˆë‹¤.

        speak(q.question);

        // ì˜µì…˜ ë²„íŠ¼ ìƒì„±

        q.options.forEach(option => {

            const button = document.createElement('button');

            button.textContent = option;

            // Game Boy ìŠ¤íƒ€ì¼ ì˜µì…˜ ë²„íŠ¼: ë‹¤í¬ ê·¸ë ˆì´ ë°°ê²½, 3D ì„€ë„ìš°

            button.className = 'w-full py-3 px-4 text-left bg-[#555555] hover:bg-[#777777] text-white font-bold rounded-lg transition duration-100 gameboy-button-shadow-gray transform active:translate-y-1 active:shadow-none disabled:opacity-50 text-xs';

            button.onclick = () => handleAnswer(option);

            optionsContainer.appendChild(button);

        });

    }

    /**

     * ë‹µë³€ì„ ì²˜ë¦¬í•˜ê³  í”¼ë“œë°±ì„ í‘œì‹œí•˜ëŠ” í•¨ìˆ˜

     */

    function handleAnswer(selectedOption) {

        if (isProcessing) return;

        isProcessing = true;

        const currentQ = currentQuiz[currentQuestionIndex];

        const isCorrect = selectedOption === currentQ.correctAnswer;

        const optionButtons = optionsContainer.querySelectorAll('button');

        // ëª¨ë“  ë²„íŠ¼ ë¹„í™œì„±í™”

        optionButtons.forEach(btn => btn.disabled = true);

        // í”¼ë“œë°± ë©”ì‹œì§€ ì„¤ì • ë° ì• ë‹ˆë©”ì´ì…˜

        feedbackMessage.classList.remove('hidden', 'bg-red-700', 'bg-green-700');

        

        let feedbackText = '';

        if (isCorrect) {

            score++;

            feedbackMessage.classList.add('bg-green-700');

            feedbackText = `ì •ë‹µì…ë‹ˆë‹¤! ğŸ‰ ${currentQ.explanation}`;

            speak("ì •ë‹µì…ë‹ˆë‹¤!");

        } else {

            feedbackMessage.classList.add('bg-red-700');

            // ì˜¤ë‹µ ë²„íŠ¼ í‘œì‹œ (ë¹¨ê°„ìƒ‰ìœ¼ë¡œ í•˜ì´ë¼ì´íŠ¸)

            const wrongButton = Array.from(optionButtons).find(btn => btn.textContent === selectedOption);

            if (wrongButton) {

                // ê¸°ì¡´ Game Boy ìŠ¤íƒ€ì¼ ì œê±°

                wrongButton.classList.remove('bg-[#555555]', 'hover:bg-[#777777]', 'gameboy-button-shadow-gray', 'active:translate-y-1', 'active:shadow-none');

                // ì˜¤ë¥˜ ìŠ¤íƒ€ì¼ ì ìš©

                wrongButton.classList.add('bg-red-600', 'shadow-[0_4px_0_0_#A00000]');

            }

            

            // ì •ë‹µ ë²„íŠ¼ í‘œì‹œ (ë…¹ìƒ‰ìœ¼ë¡œ í•˜ì´ë¼ì´íŠ¸)

            const correctButton = Array.from(optionButtons).find(btn => btn.textContent === currentQ.correctAnswer);

            if (correctButton) {

                // ê¸°ì¡´ Game Boy ìŠ¤íƒ€ì¼ ì œê±°

                correctButton.classList.remove('bg-[#555555]', 'hover:bg-[#777777]', 'gameboy-button-shadow-gray', 'active:translate-y-1', 'active:shadow-none');

                // ì •ë‹µ ìŠ¤íƒ€ì¼ ì ìš©

                correctButton.classList.add('bg-green-600', 'shadow-[0_4px_0_0_#1e4620]');

            }

            feedbackText = `ì˜¤ë‹µì…ë‹ˆë‹¤. ğŸ˜­ ì •ë‹µ: ${currentQ.correctAnswer}. í•´ì„¤: ${currentQ.explanation}`;

            speak("ì˜¤ë‹µì…ë‹ˆë‹¤. ë‹¤ì‹œ ë„ì „í•˜ì„¸ìš”!");

        }

        

        feedbackMessage.innerHTML = `<span class="block mb-1 font-bold">${isCorrect ? 'ì •ë‹µ!' : 'ì˜¤ë‹µ!'}</span> ${feedbackText}`;

        scoreDisplay.textContent = `ì ìˆ˜: ${score}`;

        // ì ì‹œ í›„ ë‹¤ìŒ ë¬¸ì œ ë¡œë“œ

        setTimeout(() => {

            currentQuestionIndex++;

            loadQuestion();

            isProcessing = false;

        }, 4000); // 4ì´ˆ í›„ì— ë‹¤ìŒ ë¬¸ì œë¡œ ë„˜ì–´ê° (í•´ì„¤ ì½ì„ ì‹œê°„)

    }

    /**

     * ê²Œì„ ì¢…ë£Œ í™”ë©´ì„ í‘œì‹œí•˜ëŠ” í•¨ìˆ˜

     */

    function showEndGame() {

        const totalQuestions = currentQuiz.length;

        const finalMessage = `í€´ì¦ˆ ì™„ë£Œ! ë‹¹ì‹ ì˜ ì ìˆ˜ëŠ” ${score} / ${totalQuestions} ì ì…ë‹ˆë‹¤.`;

        

        quizGameArea.classList.add('hidden');

        quizGenerationArea.classList.remove('hidden');

        

        statusMessage.classList.remove('text-red-500', 'text-green-500');

        statusMessage.classList.add(score / totalQuestions > 0.6 ? 'text-green-700' : 'text-red-600');

        statusMessage.innerHTML = `<span class="font-bold text-sm block">${finalMessage}</span> <span class="text-xs">ìƒˆë¡œìš´ ì£¼ì œë¡œ í€´ì¦ˆë¥¼ ë§Œë“¤ì–´ë³´ì„¸ìš”!</span>`;

        // ìƒíƒœ ì´ˆê¸°í™”

        currentQuiz = [];

        currentQuestionIndex = 0;

        score = 0;

        topicInput.value = '';

        speak(finalMessage);

    }

    /**

     * ë©”ì¸ í€´ì¦ˆ ìƒì„± ë²„íŠ¼ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬

     */

    generateButton.addEventListener('click', async () => {

        if (isProcessing) return;

        

        const topic = topicInput.value.trim();

        if (!topic) {

            statusMessage.textContent = 'í€´ì¦ˆ ì£¼ì œë¥¼ ì…ë ¥í•´ ì£¼ì„¸ìš”!';

            statusMessage.classList.add('text-red-600');

            return;

        }
        if (!API_KEY) {

            statusMessage.textContent = '.env íŒŒì¼ì— VITE_GEMINI_API_KEYë¥¼ ì„¤ì •í•´ ì£¼ì„¸ìš”.';

            statusMessage.classList.add('text-red-600');

            return;

        }

        isProcessing = true;

        generateButton.disabled = true;

        statusMessage.textContent = `"${topic}"ì— ëŒ€í•œ í€´ì¦ˆë¥¼ AIê°€ ìƒì„± ì¤‘ì…ë‹ˆë‹¤... ì ì‹œë§Œ ê¸°ë‹¤ë ¤ ì£¼ì„¸ìš”.`;

        statusMessage.classList.remove('text-red-600', 'text-green-700');

        

        quizGameArea.classList.add('hidden');

        try {

            const quizData = await generateQuizContent(topic);

            

            if (quizData && quizData.length > 0) {

                currentQuiz = quizData;

                currentQuestionIndex = 0;

                score = 0;

                

                quizGenerationArea.classList.add('hidden');

                quizGameArea.classList.remove('hidden');

                

                statusMessage.textContent = 'í€´ì¦ˆê°€ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤! ì§€ê¸ˆë¶€í„° ê²Œì„ì„ ì‹œì‘í•©ë‹ˆë‹¤.';

                statusMessage.classList.add('text-green-700');

                loadQuestion();

            } else {

                statusMessage.textContent = 'í€´ì¦ˆë¥¼ ìƒì„±í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. ì£¼ì œë¥¼ ëª…í™•í•˜ê²Œ ë‹¤ì‹œ ì…ë ¥í•´ ë³´ì„¸ìš”.';

                statusMessage.classList.add('text-red-600');

            }

        } catch (error) {

            console.error(error);

            statusMessage.textContent = `í€´ì¦ˆ ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${error.message}.`;

            statusMessage.classList.add('text-red-600');

        } finally {

            isProcessing = false;

            generateButton.disabled = false;

            setTimeout(() => statusMessage.textContent = '', 5000); // 5ì´ˆ í›„ ë©”ì‹œì§€ ìˆ¨ê¹€

        }

    });

</script>

  </body>

</html>
